---
title: sb3) Kafka란?
author: cotchan 
date: 2021-05-01 19:57:21 +0800 
categories: [Spring-Boot3]
tags: [kafka] 
---

+ **이 포스팅은 개인 공부 목적으로 작성한 포스팅입니다**

---

## 1. 카프카 구성 요소

+ **카프카는 `Producer`, `Brokers`, `Consumer`로 구성됩니다.**

+ **메시지, 이벤트, 데이터를 생성하는 쪽을 `Producer`라고 합니다.**

+ **메시지, 이벤트, 데이터를 쓰는 측, 받아가는 측을 `Consumer`라고 합니다.**

+ **`카프카는 중간에서 메시지를 전달해주는 역할`을 합니다.**
  + 카프카는 메시지 파이프라인을 잇게 해줍니다.
  + 카프카 자체는 메시지 브로커의 역할을 합니다.
  + 단, 메시지를 전달하는데 분산으로 처리해서 빠릅니다.

+ **카프카는 내부적으로 `분산커밋 로그라고 하는 큐`를 가지고 있습니다.**

[카프카 구성 요소 이미지]

---

## 2. 카프카 사용 방법 

+ **이벤트가 발생했으면 `그 이벤트를 메시지로 바꿔서 카프카에 던집니다.`**
+ **'카프카에 던진다'는 의미는 `카프카한테 메시지(로그)를 커밋한다는 의미`입니다.**
+ 그리고 Consumer는 커밋 로그로부터 로그를 원하는 대로 읽어나갑니다. 

---

## 2. about DATA

[토픽/파티션 이미지]

---

## 2-1. 파티션

+ **`카프카에서 실제 데이터는 파티션에 저장되어 있습니다.`**
+ 파티션에는 순차적이고 불변적인 일련의 메시지들이 추가됩니다.
+ **`파티션의 용도는 분산이 목적`입니다.**
  + 분산처리를 하면 `패럴리즘이 높아집니다.` (처리량을 높이기 위한 목적)
  + 한 명이 처리하는 걸 세 명이 나눠서 처리하면 처리량이 높아지는 원리 

+ 이미 발생된 로그(이벤트)는 바꿀 수 없습니다.
+ 또한 카프카는 무한으로 데이터를 저장할 수 없기 때문에 오래된 메시지는 제거하는데, 그 전략 알고리즘을 선택할 수 있습니다.
  + ex. 3일마다 지워라, 100개가 넘으면 지워라 등
  + 단, 앞에서부터 지우게 됩니다.

--- 

## 2-2. Topic

+ **토픽은 일종의 `URL` 같은 개념입니다.**

+ Producer가 kafka에 대고 메시지를 전달할 때는 토픽이 필요합니다.
  + 특정 토픽에다가 대고 메시지를 전달합니다.
  + **그래서 `토픽 단위로` 메시지를 주고 받습니다.**
  + 즉, 카프카에 있는 토픽에다가 대고 메시지를 produce 합니다.

+ **데이터 관점에서 중요한 점은 `데이터는 토픽 단위로 저장됩니다.`**
  + 그래서 토픽은 논리적 단위, 파티션은 물리적 단위라고 할 수 있습니다.
+ 제일 중요한 점은, **`토픽 자체(하나의 토픽)는 여러 개의 파티션으로 구성되어 있습니다.`**

+ 이 파티션이 커밋 로그 같은 개념입니다.
  + kafka 내부적으로는 분산커밋로그(== 큐)가 있습니다.
  + '분산'이라는 이름이 붙는 이유는 여러 개의 파티션에서 토픽을 처리하므로 분산처리한다는 뜻입니다. 
    + 파티션이 여러개니까 파티션이 여러 서버에 나눠져 있습니다.
  + 예를 들어, 카프카 브로커(서버)를 3개 띄우고, 토픽을 세 개를 만들면 3개의 토픽이 각 서버마다 1개씩 존재합니다.
  
+ 우리가 어떤 토픽에다가 대고 메시지를 쏘면 이건 어느 파티션으로 전달될까? 를 궁금해야 합니다.
  + producer가 쏜 메시지가 어느 파티션에 가는지에 대한 로직은 producer 쪽에서 구현하게 되어 있습니다.
  + 기본적으로는 라운드 로빈 방식으로 구현되어 있습니다.

---

## 3. 컨슈머의 Offset 포인팅

+ 컨슈머는 offset 포인터(메시지 아이디)를 이용해서 어디까지 메시지를 읽었는지를 기록합니다.
  + 컨슈머들은 offset, partition, topic으로 메시지를 추적합니다.
+ 카프카에서 요청이 늘어나게 되면 api 콜을 계속하는 게 아니라, 커밋 로그에 요청을 기록합니다.

---

[컨슈머의 offset 포인팅 이미지]

---

## 4. 컨슈머와 컨슈머 그룹 
  
+ **파티션은 `컨슈머 그룹 당 오로지 하나의 컨슈머`의 접근만 허용합니다.**
  + 해당 컨슈머를 `파티션 오너`라고 합니다.

+ **`똑같은 메시지`는 `컨슈머 그룹 단위로 전파`가 됩니다.**
  + 즉, 컨슈머 3개를 같은 컨슈머 그룹으로 지정하지 않으면 똑같은 메시지가 3개를 각각 받게 됩니다.
+ **그러므로 `똑같은 메시지에 대해서`, `컨슈머 그룹안에서는 하나의 컨슈머가 처리하는 게 보장`됩니다.**
+ 그래서 컨슈머 그룹으로 묶이면 하나의 토픽에 대해서 컨슈머 그룹 내에서는 하나의 메시지만 받는 걸 보장합니다.
  + 단, 컨슈머 그룹에서 어떤 컨슈머가 받을지는 순서가 보장되지 않습니다.


+ **컨슈머 그룹의 장점**
  + 컨슈머 그룹의 장점 중 하나는 `rebalancing` 입니다.
    + 즉, 컨슈머 스스로 파티션 재분배처리를 합니다. 
    + **그룹 내 컨슈머가 죽어서 해당 메시지를 받지 못하더라도 다른 컨슈머가 그 메시지를 받게 됩니다.**
  + **그러므로 컨슈머 그룹에 대해서는 파티션으로부터 내려오는 메시지를 무조건 처리할 수 있습니다.**
    + 특정 토픽에 대한 메시지는 무조건 이 컨슈머 그룹에서 처리가 됩니다.

---

[컨슈머와 컨슈머 그룹 이미지]
 

---

## 5. 리플리카(Replicas)

+ **파티션의 "백업" 개념**
+ **특정 파티션에 대한 `복제 파티션`을 만드는 것입니다.**
+ 파티션과 달리 데이터 손설을 막기 위한 개념입니다.
+ 그러므로 하나의 토픽을 만들 때 아래의 정보를 알려줘야 됩니다.
  + 파티션은 몇 개로 만들래?
  + 리플리카는 몇 개로 가져갈래?

+ 리플리카는 다다익선의 개념이 X
  + 복제를 하는데 시간이 많이 걸리기 때문에 리플리카 값을 마냥 많이 주는 게 좋은 게 아닙니다.
+ 리플리카에는 리더 개념이 있습니다. 
  + 우선 리더 파티션으로부터 데이터를 READ하고, 나머지 부하 파티션들은 데이터를 쌓아두기만 합니다. (여기서 읽지 않음)
  + 그리고 리더 파티션이 죽으면 그 때 부하 파티션을 사용합니다.

---

[파티션 복제 이미지] 

---


## 6. 렉(lag) 현상

+ 컨슈머가 읽는 것보다 프로듀서가 메시지를 쏘는 게 더 빠를 때 발생하는 현상
+ ex. 나는 13번까지 밖에 못 읽었는데 파티션에 이미 20번까지 꽂혀있는 경우

[렉 이미지]

---

+ 출처
    + [[스터디/9기] 단순 CRUD는 그만! 웹 백엔드 시스템 구현(Spring Boot)](https://programmers.co.kr/learn/courses/11694) 


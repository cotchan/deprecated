---
title: bcs) Blocking IO vs Non-Blocking IO(feat. Sync, Async)
author: cotchan 
date: 2021-07-19 01:31:21 +0800 
categories: [ComputerScience, BCS]
tags: [bcs]
---

+ **아래 출처의 내용들을 바탕으로 작성한 내용입니다.**

---

## 1. Sync와 Async

+ **Sync와 Async를 구분하는 기준은 `작업순서`입니다.**

---

## 1-1. 동기식 모델(Sync)
  
+ 모든 작업들이 일련의 순서를 따르며 그 순서에 맞게 동작합니다.
+ A,B,C 순서대로 작업이 시작되었다면 A,B,C 순서대로 작업이 끝나야합니다.
+ 설령 여러 작업이 동시에 처리되어 있다고 해도, 작업이 처리되는 순서가 보장된다면 이는 동기식 모델이라고 할 수 있습니다.
+ **동기식 처리 모델에서 알아야 할 것은 `작업의 순서가 보장된다는 점`뿐입니다.**


---

## 1-2. 비동기식 모델(Async)

+ **비동기식 모델은 `작업의 순서가 보장되지 않습니다.`**
  + 즉, A,B,C 순서로 작업이 시작되어도 A,B,C 순서로 작업이 끝난다고 보장할 수 없습니다.

+ 비동기식 처리 모델이 이득을 보는 경우는 `각 작업이 분리될 수 있으며`, `Latency(대기시간)`이 큰 경우입니다.
  + 예를 들어 각 클라이언트나 작업별로 Latency가 발생하는 `네트워크 처리`나 `File I/O` 등이 훌륭한 적용 예시입니다.

---

## 2. 블로킹과 논블로킹

+ **Blocking과 Non-Blocking을 구분하는 기준은 `통지`입니다.**

---

## 2-1. Blocking

+ Blocking이란 단어 그대로 작업의 멈춤, 대기(Wait)를 의미합니다. 즉, `작업을 시작하고 작업이 끝날때까지 대기`하다가 완료 통지를 받습니다.
  + 단순히 Blocking은 그저 `작업을 수행하는데 있어서 대기시간을 갖는다`는 의미입니다.

---

## 2-2. Non-Blocking

+ **Non-Blocking이란 `작업 완료를 나중에 통지받는 개념`입니다.**
  + 작업의 시작 이후 완료시까지 대기하지 않고, 완료 처리를 받습니다.
  + **즉, `내부 동작과 무관하게 작업에 대한 완료를 처리받는 것을 의미`합니다.**

---

## 3. Blocking I/O

+ I/O 작업은 유저레벨에서 직접 수행할 수 없습니다. 실제 I/O를 수행하는 것은 커널레벨에서만 가능합니다.
+ 따라서 유저 프로세스(스레드)는 커널에게 I/O 요청을 해야합니다. 
+ **I/O에서 블로킹 형태의 작업은, 유저 프로세스가 커널에게 I/O를 호출하는 함수를 호출하고, 커널이 작업을 완료하면 함수가 작업 결과를 반환합니다.**
  + I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기해야 합니다.

---

## 3-1. 블로킹 I/O 장점

---

## 3-2. 블로킹 I/O 단점

+ **리소스 낭비가 심합니다.**
  + ex. 커넥션 수가 많아짐에 따라 늘어나는 쓰레드 
  + 커널 I/O 완료를 기다리는 대기시간


+ 만약 여러 클라이언트가 접속하는 서버를 블로킹방식으로 구현한다고 가정해보면...
+ **I/O 작업이 blocking 방식으로 구현되면 하나의 클라이언트가 I/O 작업을 진행하면 해당 프로세스가 진행하는 작업을 중지하게 됩니다. 그러므로 `다른 클라이언트의 작업에 영향을 미치지 않게 하기 위해서` `클라이언트 별로 별도의 쓰레드를 만들어 연결시켜줘야 합니다.` `그러면 쓰레드 수는 접속자 수가 많아질수록 증가하게 됩니다.` 쓰레드가 많으면 CPU의 컨텍스트 스위칭 횟수가 증가할 것이며, 이때 사용되는 컨텍스트 스위칭 비용때문에 실제 작업하는 양에 비해 훨씬 비효율적으로 동작합니다.**

---

## 4. Non-Blocking I/O

+ **Blocking 방식의 비효율성을 극복하고자 만들어진 것이 Non-Blocking 방식입니다.**
+ Non-Blocking은 I/O 작업을 진행하는 동안 `유저 프로세스의 작업을 중단시키지 않습니다.`
+ 유저 프로세스가 커널에게 I/O를 요청하는 함수를 호출하면, 함수는 I/O를 요청한 다음` 진행상황과 상관없이 바로 결과를 반환합니다.`
+ 즉, 호출 직후 프로그램으로부터 제어가 돌아옴으로써 시스템 호출 종료를 기다리지 않고 다음 처리로 넘어갈 수 있는 것입니다.


---

## 4-1. 논블로킹 I/O 장점

---

## 4-2. 논블로킹 I/O 단점





---
+ 출처
    + []()
    + []()
